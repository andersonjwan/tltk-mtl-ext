# Generated from STQL.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3/")
        buf.write("\u0171\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\3\2\3\2\3\2\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3<\n\3\3\3\3")
        buf.write("\3\3\3\5\3A\n\3\3\3\3\3\3\3\5\3F\n\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\5\3^\n\3\3\3\3\3\3\3\5\3c\n\3\3\3\3\3")
        buf.write("\3\3\3\3\5\3i\n\3\3\3\3\3\3\3\3\3\5\3o\n\3\3\3\3\3\3\3")
        buf.write("\3\3\5\3u\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\7\3~\n\3\f\3")
        buf.write("\16\3\u0081\13\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\5\4\u0090\n\4\3\4\3\4\3\4\5\4\u0095\n\4")
        buf.write("\3\4\3\4\3\4\5\4\u009a\n\4\3\4\3\4\3\4\3\4\5\4\u00a0\n")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\5\4\u00a7\n\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\5\4\u00ae\n\4\3\4\3\4\3\4\3\4\3\4\5\4\u00b5\n\4\3\4")
        buf.write("\3\4\5\4\u00b9\n\4\3\4\3\4\3\4\7\4\u00be\n\4\f\4\16\4")
        buf.write("\u00c1\13\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\5\3\5\5\5\u00cf\n\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6\u00fd\n\6\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7\u0107\n\7\3\7\3\7\3\b\3")
        buf.write("\b\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\5\n\u0115\n\n\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\r\3\r")
        buf.write("\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\17\3")
        buf.write("\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\20")
        buf.write("\3\20\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\21\3\22\3\22\3\22\3\22\5\22\u014b\n\22\3\22\3")
        buf.write("\22\3\22\5\22\u0150\n\22\3\22\3\22\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\25\3\25\3\25")
        buf.write("\3\25\3\25\3\26\3\26\3\26\3\26\3\26\3\27\3\27\3\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\2\4\4\6\30\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$&(*,\2\b\3\2,-\3\2\37 \4\2\23\23..")
        buf.write("\4\2\r\r\17\17\3\2+-\4\2\16\16\20\20\2\u0198\2.\3\2\2")
        buf.write("\2\4]\3\2\2\2\6\u00b8\3\2\2\2\b\u00ce\3\2\2\2\n\u00fc")
        buf.write("\3\2\2\2\f\u00fe\3\2\2\2\16\u010a\3\2\2\2\20\u010c\3\2")
        buf.write("\2\2\22\u0114\3\2\2\2\24\u0116\3\2\2\2\26\u011c\3\2\2")
        buf.write("\2\30\u0121\3\2\2\2\32\u0126\3\2\2\2\34\u012d\3\2\2\2")
        buf.write("\36\u0138\3\2\2\2 \u013f\3\2\2\2\"\u0146\3\2\2\2$\u0153")
        buf.write("\3\2\2\2&\u0158\3\2\2\2(\u015f\3\2\2\2*\u0164\3\2\2\2")
        buf.write(",\u0169\3\2\2\2./\5\4\3\2/\60\7\2\2\3\60\3\3\2\2\2\61")
        buf.write("\62\b\3\1\2\62\63\7\r\2\2\63\64\5\4\3\2\64\65\7\16\2\2")
        buf.write("\65^\3\2\2\2\66^\7*\2\2\678\7\24\2\28^\5\4\3\249;\7\30")
        buf.write("\2\2:<\5\24\13\2;:\3\2\2\2;<\3\2\2\2<=\3\2\2\2=^\5\4\3")
        buf.write("\23>@\7\31\2\2?A\5\24\13\2@?\3\2\2\2@A\3\2\2\2AB\3\2\2")
        buf.write("\2B^\5\4\3\22CE\7\32\2\2DF\5\24\13\2ED\3\2\2\2EF\3\2\2")
        buf.write("\2FG\3\2\2\2G^\5\4\3\21HI\7\'\2\2IJ\7\25\2\2JK\7.\2\2")
        buf.write("KL\7\26\2\2L^\t\2\2\2MN\7(\2\2NO\7\25\2\2OP\7.\2\2PQ\7")
        buf.write("\26\2\2Q^\7-\2\2RS\7.\2\2ST\7\27\2\2T^\7.\2\2UV\5\f\7")
        buf.write("\2VW\5\4\3\7W^\3\2\2\2XY\7\"\2\2Y^\5\6\4\2Z^\5\b\5\2[")
        buf.write("^\5\n\6\2\\^\7/\2\2]\61\3\2\2\2]\66\3\2\2\2]\67\3\2\2")
        buf.write("\2]9\3\2\2\2]>\3\2\2\2]C\3\2\2\2]H\3\2\2\2]M\3\2\2\2]")
        buf.write("R\3\2\2\2]U\3\2\2\2]X\3\2\2\2]Z\3\2\2\2][\3\2\2\2]\\\3")
        buf.write("\2\2\2^\177\3\2\2\2_`\f\20\2\2`b\7\33\2\2ac\5\24\13\2")
        buf.write("ba\3\2\2\2bc\3\2\2\2cd\3\2\2\2d~\5\4\3\21ef\f\17\2\2f")
        buf.write("h\7\34\2\2gi\5\24\13\2hg\3\2\2\2hi\3\2\2\2ij\3\2\2\2j")
        buf.write("~\5\4\3\20kl\f\16\2\2ln\7\35\2\2mo\5\24\13\2nm\3\2\2\2")
        buf.write("no\3\2\2\2op\3\2\2\2p~\5\4\3\17qr\f\r\2\2rt\7\36\2\2s")
        buf.write("u\5\24\13\2ts\3\2\2\2tu\3\2\2\2uv\3\2\2\2v~\5\4\3\16w")
        buf.write("x\f\f\2\2xy\t\3\2\2y~\5\4\3\rz{\f\13\2\2{|\7#\2\2|~\5")
        buf.write("\4\3\f}_\3\2\2\2}e\3\2\2\2}k\3\2\2\2}q\3\2\2\2}w\3\2\2")
        buf.write("\2}z\3\2\2\2~\u0081\3\2\2\2\177}\3\2\2\2\177\u0080\3\2")
        buf.write("\2\2\u0080\5\3\2\2\2\u0081\177\3\2\2\2\u0082\u0083\b\4")
        buf.write("\1\2\u0083\u0084\7\r\2\2\u0084\u0085\5\6\4\2\u0085\u0086")
        buf.write("\7\16\2\2\u0086\u00b9\3\2\2\2\u0087\u00b9\7\f\2\2\u0088")
        buf.write("\u00b9\5\26\f\2\u0089\u008a\7\24\2\2\u008a\u00b9\5\6\4")
        buf.write("\f\u008b\u008c\7&\2\2\u008c\u00b9\5\6\4\n\u008d\u008f")
        buf.write("\7\30\2\2\u008e\u0090\5\24\13\2\u008f\u008e\3\2\2\2\u008f")
        buf.write("\u0090\3\2\2\2\u0090\u0091\3\2\2\2\u0091\u00b9\5\6\4\t")
        buf.write("\u0092\u0094\7\31\2\2\u0093\u0095\5\24\13\2\u0094\u0093")
        buf.write("\3\2\2\2\u0094\u0095\3\2\2\2\u0095\u0096\3\2\2\2\u0096")
        buf.write("\u00b9\5\6\4\b\u0097\u0099\7\32\2\2\u0098\u009a\5\24\13")
        buf.write("\2\u0099\u0098\3\2\2\2\u0099\u009a\3\2\2\2\u009a\u009b")
        buf.write("\3\2\2\2\u009b\u00b9\5\6\4\7\u009c\u009d\5\4\3\2\u009d")
        buf.write("\u009f\7\33\2\2\u009e\u00a0\5\24\13\2\u009f\u009e\3\2")
        buf.write("\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\u00a2")
        buf.write("\5\6\4\6\u00a2\u00b9\3\2\2\2\u00a3\u00a4\5\4\3\2\u00a4")
        buf.write("\u00a6\7\34\2\2\u00a5\u00a7\5\24\13\2\u00a6\u00a5\3\2")
        buf.write("\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00a9")
        buf.write("\5\6\4\5\u00a9\u00b9\3\2\2\2\u00aa\u00ab\5\4\3\2\u00ab")
        buf.write("\u00ad\7\35\2\2\u00ac\u00ae\5\24\13\2\u00ad\u00ac\3\2")
        buf.write("\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00af\3\2\2\2\u00af\u00b0")
        buf.write("\5\6\4\4\u00b0\u00b9\3\2\2\2\u00b1\u00b2\5\4\3\2\u00b2")
        buf.write("\u00b4\7\36\2\2\u00b3\u00b5\5\24\13\2\u00b4\u00b3\3\2")
        buf.write("\2\2\u00b4\u00b5\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b7")
        buf.write("\5\6\4\3\u00b7\u00b9\3\2\2\2\u00b8\u0082\3\2\2\2\u00b8")
        buf.write("\u0087\3\2\2\2\u00b8\u0088\3\2\2\2\u00b8\u0089\3\2\2\2")
        buf.write("\u00b8\u008b\3\2\2\2\u00b8\u008d\3\2\2\2\u00b8\u0092\3")
        buf.write("\2\2\2\u00b8\u0097\3\2\2\2\u00b8\u009c\3\2\2\2\u00b8\u00a3")
        buf.write("\3\2\2\2\u00b8\u00aa\3\2\2\2\u00b8\u00b1\3\2\2\2\u00b9")
        buf.write("\u00bf\3\2\2\2\u00ba\u00bb\f\13\2\2\u00bb\u00bc\t\3\2")
        buf.write("\2\u00bc\u00be\5\6\4\f\u00bd\u00ba\3\2\2\2\u00be\u00c1")
        buf.write("\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0")
        buf.write("\7\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c2\u00c3\7\r\2\2\u00c3")
        buf.write("\u00c4\5\b\5\2\u00c4\u00c5\7\16\2\2\u00c5\u00cf\3\2\2")
        buf.write("\2\u00c6\u00c7\5\30\r\2\u00c7\u00c8\7\26\2\2\u00c8\u00c9")
        buf.write("\7,\2\2\u00c9\u00cf\3\2\2\2\u00ca\u00cb\5\32\16\2\u00cb")
        buf.write("\u00cc\7\26\2\2\u00cc\u00cd\7,\2\2\u00cd\u00cf\3\2\2\2")
        buf.write("\u00ce\u00c2\3\2\2\2\u00ce\u00c6\3\2\2\2\u00ce\u00ca\3")
        buf.write("\2\2\2\u00cf\t\3\2\2\2\u00d0\u00d1\7\r\2\2\u00d1\u00d2")
        buf.write("\5\n\6\2\u00d2\u00d3\7\16\2\2\u00d3\u00fd\3\2\2\2\u00d4")
        buf.write("\u00d5\5\34\17\2\u00d5\u00d6\7\26\2\2\u00d6\u00d7\7,\2")
        buf.write("\2\u00d7\u00fd\3\2\2\2\u00d8\u00d9\5\36\20\2\u00d9\u00da")
        buf.write("\7\26\2\2\u00da\u00db\7,\2\2\u00db\u00fd\3\2\2\2\u00dc")
        buf.write("\u00dd\5 \21\2\u00dd\u00de\7\26\2\2\u00de\u00df\7,\2\2")
        buf.write("\u00df\u00fd\3\2\2\2\u00e0\u00e1\5\"\22\2\u00e1\u00e2")
        buf.write("\7\26\2\2\u00e2\u00e3\7,\2\2\u00e3\u00fd\3\2\2\2\u00e4")
        buf.write("\u00e5\5$\23\2\u00e5\u00e6\7\26\2\2\u00e6\u00e7\7,\2\2")
        buf.write("\u00e7\u00fd\3\2\2\2\u00e8\u00e9\5&\24\2\u00e9\u00ea\7")
        buf.write("\26\2\2\u00ea\u00eb\7,\2\2\u00eb\u00fd\3\2\2\2\u00ec\u00ed")
        buf.write("\5(\25\2\u00ed\u00ee\7\26\2\2\u00ee\u00ef\7-\2\2\u00ef")
        buf.write("\u00fd\3\2\2\2\u00f0\u00f1\5(\25\2\u00f1\u00f2\7\27\2")
        buf.write("\2\u00f2\u00f3\5(\25\2\u00f3\u00fd\3\2\2\2\u00f4\u00f5")
        buf.write("\5*\26\2\u00f5\u00f6\7\26\2\2\u00f6\u00f7\7,\2\2\u00f7")
        buf.write("\u00fd\3\2\2\2\u00f8\u00f9\5,\27\2\u00f9\u00fa\7\26\2")
        buf.write("\2\u00fa\u00fb\7,\2\2\u00fb\u00fd\3\2\2\2\u00fc\u00d0")
        buf.write("\3\2\2\2\u00fc\u00d4\3\2\2\2\u00fc\u00d8\3\2\2\2\u00fc")
        buf.write("\u00dc\3\2\2\2\u00fc\u00e0\3\2\2\2\u00fc\u00e4\3\2\2\2")
        buf.write("\u00fc\u00e8\3\2\2\2\u00fc\u00ec\3\2\2\2\u00fc\u00f0\3")
        buf.write("\2\2\2\u00fc\u00f4\3\2\2\2\u00fc\u00f8\3\2\2\2\u00fd\13")
        buf.write("\3\2\2\2\u00fe\u00ff\7\21\2\2\u00ff\u0106\7\r\2\2\u0100")
        buf.write("\u0107\5\16\b\2\u0101\u0107\5\20\t\2\u0102\u0103\5\16")
        buf.write("\b\2\u0103\u0104\7\22\2\2\u0104\u0105\5\20\t\2\u0105\u0107")
        buf.write("\3\2\2\2\u0106\u0100\3\2\2\2\u0106\u0101\3\2\2\2\u0106")
        buf.write("\u0102\3\2\2\2\u0107\u0108\3\2\2\2\u0108\u0109\7\16\2")
        buf.write("\2\u0109\r\3\2\2\2\u010a\u010b\t\4\2\2\u010b\17\3\2\2")
        buf.write("\2\u010c\u010d\7!\2\2\u010d\u010e\7\22\2\2\u010e\u010f")
        buf.write("\5\22\n\2\u010f\21\3\2\2\2\u0110\u0115\7.\2\2\u0111\u0112")
        buf.write("\7.\2\2\u0112\u0113\7\22\2\2\u0113\u0115\5\22\n\2\u0114")
        buf.write("\u0110\3\2\2\2\u0114\u0111\3\2\2\2\u0115\23\3\2\2\2\u0116")
        buf.write("\u0117\t\5\2\2\u0117\u0118\t\6\2\2\u0118\u0119\7\22\2")
        buf.write("\2\u0119\u011a\t\6\2\2\u011a\u011b\t\7\2\2\u011b\25\3")
        buf.write("\2\2\2\u011c\u011d\7\3\2\2\u011d\u011e\7\r\2\2\u011e\u011f")
        buf.write("\7.\2\2\u011f\u0120\7\16\2\2\u0120\27\3\2\2\2\u0121\u0122")
        buf.write("\7\4\2\2\u0122\u0123\7\r\2\2\u0123\u0124\5\6\4\2\u0124")
        buf.write("\u0125\7\16\2\2\u0125\31\3\2\2\2\u0126\u0127\7\5\2\2\u0127")
        buf.write("\u0128\7\r\2\2\u0128\u0129\5\30\r\2\u0129\u012a\7\22\2")
        buf.write("\2\u012a\u012b\5\30\r\2\u012b\u012c\7\16\2\2\u012c\33")
        buf.write("\3\2\2\2\u012d\u012e\7\6\2\2\u012e\u012f\7\r\2\2\u012f")
        buf.write("\u0130\7.\2\2\u0130\u0131\7\22\2\2\u0131\u0132\7)\2\2")
        buf.write("\u0132\u0133\7\22\2\2\u0133\u0134\7.\2\2\u0134\u0135\7")
        buf.write("\22\2\2\u0135\u0136\7)\2\2\u0136\u0137\7\16\2\2\u0137")
        buf.write("\35\3\2\2\2\u0138\u0139\7\7\2\2\u0139\u013a\7\r\2\2\u013a")
        buf.write("\u013b\7.\2\2\u013b\u013c\7\22\2\2\u013c\u013d\7)\2\2")
        buf.write("\u013d\u013e\7\16\2\2\u013e\37\3\2\2\2\u013f\u0140\7\b")
        buf.write("\2\2\u0140\u0141\7\r\2\2\u0141\u0142\7.\2\2\u0142\u0143")
        buf.write("\7\22\2\2\u0143\u0144\7)\2\2\u0144\u0145\7\16\2\2\u0145")
        buf.write("!\3\2\2\2\u0146\u0147\7\5\2\2\u0147\u014a\7\r\2\2\u0148")
        buf.write("\u014b\5\36\20\2\u0149\u014b\5 \21\2\u014a\u0148\3\2\2")
        buf.write("\2\u014a\u0149\3\2\2\2\u014b\u014c\3\2\2\2\u014c\u014f")
        buf.write("\7\22\2\2\u014d\u0150\5\36\20\2\u014e\u0150\5 \21\2\u014f")
        buf.write("\u014d\3\2\2\2\u014f\u014e\3\2\2\2\u0150\u0151\3\2\2\2")
        buf.write("\u0151\u0152\7\16\2\2\u0152#\3\2\2\2\u0153\u0154\7\4\2")
        buf.write("\2\u0154\u0155\7\r\2\2\u0155\u0156\7.\2\2\u0156\u0157")
        buf.write("\7\16\2\2\u0157%\3\2\2\2\u0158\u0159\7\5\2\2\u0159\u015a")
        buf.write("\7\r\2\2\u015a\u015b\5\30\r\2\u015b\u015c\7\22\2\2\u015c")
        buf.write("\u015d\5\30\r\2\u015d\u015e\7\16\2\2\u015e\'\3\2\2\2\u015f")
        buf.write("\u0160\7\t\2\2\u0160\u0161\7\r\2\2\u0161\u0162\7.\2\2")
        buf.write("\u0162\u0163\7\16\2\2\u0163)\3\2\2\2\u0164\u0165\7\n\2")
        buf.write("\2\u0165\u0166\7\r\2\2\u0166\u0167\7.\2\2\u0167\u0168")
        buf.write("\7\16\2\2\u0168+\3\2\2\2\u0169\u016a\7\5\2\2\u016a\u016b")
        buf.write("\7\r\2\2\u016b\u016c\5*\26\2\u016c\u016d\7\22\2\2\u016d")
        buf.write("\u016e\5*\26\2\u016e\u016f\7\16\2\2\u016f-\3\2\2\2\33")
        buf.write(";@E]bhnt}\177\u008f\u0094\u0099\u009f\u00a6\u00ad\u00b4")
        buf.write("\u00b8\u00bf\u00ce\u00fc\u0106\u0114\u014a\u014f")
        return buf.getvalue()


class STQLParser ( Parser ):

    grammarFileName = "STQL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'BB'", "'area'", "'ratio'", "'dist'", 
                     "'lat_dist'", "'lon_dist'", "'class'", "'prob'", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'['", "']'", "'@'", "','", 
                     "'_'", "<INVALID>", "'-'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'C_TIME'", 
                     "'C_FRAME'", "<INVALID>", "<INVALID>", "'inf'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "WS", "SET", "LPAREN", "RPAREN", "LBRACK", 
                      "RBRACK", "AT", "COMMA", "UNDERSCORE", "NEGATION", 
                      "MINUS", "RELOP", "EQUALITYOP", "NEXTOP", "FUTUREOP", 
                      "GLOBALLYOP", "UNTILOP", "RELEASEOP", "UNTILNSOP", 
                      "RELEASENSOP", "ANDOP", "OROP", "QUANTIFIEROP", "SPQUANTIFIEROP", 
                      "PROPOP", "IMPLIESOP", "EQUIVOP", "SPACEOP", "CONST_TIME", 
                      "CONST_FRAME", "CRT", "BOOLEAN", "INF", "REAL", "INT", 
                      "VAR", "PREDICATE" ]

    RULE_stqlSpecification = 0
    RULE_phi = 1
    RULE_tau = 2
    RULE_pi = 3
    RULE_theta = 4
    RULE_freezeTime = 5
    RULE_timeVarDecl = 6
    RULE_objVarDecl = 7
    RULE_varList = 8
    RULE_interval = 9
    RULE_funcBB = 10
    RULE_funcAreaTau = 11
    RULE_funcRatioAreaTau = 12
    RULE_funcDist = 13
    RULE_funcLatDist = 14
    RULE_funcLonDist = 15
    RULE_funcRatioLatLon = 16
    RULE_funcAreaTheta = 17
    RULE_funcRatioArea = 18
    RULE_funcClass = 19
    RULE_funcProb = 20
    RULE_funcRatioProb = 21

    ruleNames =  [ "stqlSpecification", "phi", "tau", "pi", "theta", "freezeTime", 
                   "timeVarDecl", "objVarDecl", "varList", "interval", "funcBB", 
                   "funcAreaTau", "funcRatioAreaTau", "funcDist", "funcLatDist", 
                   "funcLonDist", "funcRatioLatLon", "funcAreaTheta", "funcRatioArea", 
                   "funcClass", "funcProb", "funcRatioProb" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    WS=9
    SET=10
    LPAREN=11
    RPAREN=12
    LBRACK=13
    RBRACK=14
    AT=15
    COMMA=16
    UNDERSCORE=17
    NEGATION=18
    MINUS=19
    RELOP=20
    EQUALITYOP=21
    NEXTOP=22
    FUTUREOP=23
    GLOBALLYOP=24
    UNTILOP=25
    RELEASEOP=26
    UNTILNSOP=27
    RELEASENSOP=28
    ANDOP=29
    OROP=30
    QUANTIFIEROP=31
    SPQUANTIFIEROP=32
    PROPOP=33
    IMPLIESOP=34
    EQUIVOP=35
    SPACEOP=36
    CONST_TIME=37
    CONST_FRAME=38
    CRT=39
    BOOLEAN=40
    INF=41
    REAL=42
    INT=43
    VAR=44
    PREDICATE=45

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StqlSpecificationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)


        def EOF(self):
            return self.getToken(STQLParser.EOF, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_stqlSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStqlSpecification" ):
                listener.enterStqlSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStqlSpecification" ):
                listener.exitStqlSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStqlSpecification" ):
                return visitor.visitStqlSpecification(self)
            else:
                return visitor.visitChildren(self)




    def stqlSpecification(self):

        localctx = STQLParser.StqlSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_stqlSpecification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.phi(0)
            self.state = 45
            self.match(STQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhiContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return STQLParser.RULE_phi

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class OpReleaseNotStrictExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.PhiContext)
            else:
                return self.getTypedRuleContext(STQLParser.PhiContext,i)

        def RELEASENSOP(self):
            return self.getToken(STQLParser.RELEASENSOP, 0)
        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpReleaseNotStrictExpr" ):
                listener.enterOpReleaseNotStrictExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpReleaseNotStrictExpr" ):
                listener.exitOpReleaseNotStrictExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpReleaseNotStrictExpr" ):
                return visitor.visitOpReleaseNotStrictExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpUntilExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.PhiContext)
            else:
                return self.getTypedRuleContext(STQLParser.PhiContext,i)

        def UNTILOP(self):
            return self.getToken(STQLParser.UNTILOP, 0)
        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpUntilExpr" ):
                listener.enterOpUntilExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpUntilExpr" ):
                listener.exitOpUntilExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpUntilExpr" ):
                return visitor.visitOpUntilExpr(self)
            else:
                return visitor.visitChildren(self)


    class TimeConstraintExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONST_TIME(self):
            return self.getToken(STQLParser.CONST_TIME, 0)
        def MINUS(self):
            return self.getToken(STQLParser.MINUS, 0)
        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)
        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)
        def INT(self):
            return self.getToken(STQLParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeConstraintExpr" ):
                listener.enterTimeConstraintExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeConstraintExpr" ):
                listener.exitTimeConstraintExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeConstraintExpr" ):
                return visitor.visitTimeConstraintExpr(self)
            else:
                return visitor.visitChildren(self)


    class PiExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pi(self):
            return self.getTypedRuleContext(STQLParser.PiContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPiExpr" ):
                listener.enterPiExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPiExpr" ):
                listener.exitPiExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPiExpr" ):
                return visitor.visitPiExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpNextExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NEXTOP(self):
            return self.getToken(STQLParser.NEXTOP, 0)
        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpNextExpr" ):
                listener.enterOpNextExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpNextExpr" ):
                listener.exitOpNextExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpNextExpr" ):
                return visitor.visitOpNextExpr(self)
            else:
                return visitor.visitChildren(self)


    class VariableEquivalenceExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.VAR)
            else:
                return self.getToken(STQLParser.VAR, i)
        def EQUALITYOP(self):
            return self.getToken(STQLParser.EQUALITYOP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableEquivalenceExpr" ):
                listener.enterVariableEquivalenceExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableEquivalenceExpr" ):
                listener.exitVariableEquivalenceExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableEquivalenceExpr" ):
                return visitor.visitVariableEquivalenceExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpUntilNotStrictExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.PhiContext)
            else:
                return self.getTypedRuleContext(STQLParser.PhiContext,i)

        def UNTILNSOP(self):
            return self.getToken(STQLParser.UNTILNSOP, 0)
        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpUntilNotStrictExpr" ):
                listener.enterOpUntilNotStrictExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpUntilNotStrictExpr" ):
                listener.exitOpUntilNotStrictExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpUntilNotStrictExpr" ):
                return visitor.visitOpUntilNotStrictExpr(self)
            else:
                return visitor.visitChildren(self)


    class ThetaExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def theta(self):
            return self.getTypedRuleContext(STQLParser.ThetaContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThetaExpr" ):
                listener.enterThetaExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThetaExpr" ):
                listener.exitThetaExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThetaExpr" ):
                return visitor.visitThetaExpr(self)
            else:
                return visitor.visitChildren(self)


    class PredicateExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PREDICATE(self):
            return self.getToken(STQLParser.PREDICATE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateExpr" ):
                listener.enterPredicateExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateExpr" ):
                listener.exitPredicateExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateExpr" ):
                return visitor.visitPredicateExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpFutureExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FUTUREOP(self):
            return self.getToken(STQLParser.FUTUREOP, 0)
        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpFutureExpr" ):
                listener.enterOpFutureExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpFutureExpr" ):
                listener.exitOpFutureExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpFutureExpr" ):
                return visitor.visitOpFutureExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenPhiExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)
        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenPhiExpr" ):
                listener.enterParenPhiExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenPhiExpr" ):
                listener.exitParenPhiExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenPhiExpr" ):
                return visitor.visitParenPhiExpr(self)
            else:
                return visitor.visitChildren(self)


    class FrameConstraintExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONST_FRAME(self):
            return self.getToken(STQLParser.CONST_FRAME, 0)
        def MINUS(self):
            return self.getToken(STQLParser.MINUS, 0)
        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)
        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def INT(self):
            return self.getToken(STQLParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrameConstraintExpr" ):
                listener.enterFrameConstraintExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrameConstraintExpr" ):
                listener.exitFrameConstraintExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrameConstraintExpr" ):
                return visitor.visitFrameConstraintExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpGloballyExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def GLOBALLYOP(self):
            return self.getToken(STQLParser.GLOBALLYOP, 0)
        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpGloballyExpr" ):
                listener.enterOpGloballyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpGloballyExpr" ):
                listener.exitOpGloballyExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpGloballyExpr" ):
                return visitor.visitOpGloballyExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpLogicalExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.PhiContext)
            else:
                return self.getTypedRuleContext(STQLParser.PhiContext,i)

        def ANDOP(self):
            return self.getToken(STQLParser.ANDOP, 0)
        def OROP(self):
            return self.getToken(STQLParser.OROP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpLogicalExpr" ):
                listener.enterOpLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpLogicalExpr" ):
                listener.exitOpLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpLogicalExpr" ):
                return visitor.visitOpLogicalExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpFreezeTimeExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def freezeTime(self):
            return self.getTypedRuleContext(STQLParser.FreezeTimeContext,0)

        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpFreezeTimeExpr" ):
                listener.enterOpFreezeTimeExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpFreezeTimeExpr" ):
                listener.exitOpFreezeTimeExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpFreezeTimeExpr" ):
                return visitor.visitOpFreezeTimeExpr(self)
            else:
                return visitor.visitChildren(self)


    class TauExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SPQUANTIFIEROP(self):
            return self.getToken(STQLParser.SPQUANTIFIEROP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTauExpr" ):
                listener.enterTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTauExpr" ):
                listener.exitTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTauExpr" ):
                return visitor.visitTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class BoolAtomContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOLEAN(self):
            return self.getToken(STQLParser.BOOLEAN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolAtom" ):
                listener.enterBoolAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolAtom" ):
                listener.exitBoolAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolAtom" ):
                return visitor.visitBoolAtom(self)
            else:
                return visitor.visitChildren(self)


    class OpReleaseExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.PhiContext)
            else:
                return self.getTypedRuleContext(STQLParser.PhiContext,i)

        def RELEASEOP(self):
            return self.getToken(STQLParser.RELEASEOP, 0)
        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpReleaseExpr" ):
                listener.enterOpReleaseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpReleaseExpr" ):
                listener.exitOpReleaseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpReleaseExpr" ):
                return visitor.visitOpReleaseExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpPropExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.PhiContext)
            else:
                return self.getTypedRuleContext(STQLParser.PhiContext,i)

        def PROPOP(self):
            return self.getToken(STQLParser.PROPOP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpPropExpr" ):
                listener.enterOpPropExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpPropExpr" ):
                listener.exitOpPropExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpPropExpr" ):
                return visitor.visitOpPropExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpNegExprContext(PhiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PhiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NEGATION(self):
            return self.getToken(STQLParser.NEGATION, 0)
        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpNegExpr" ):
                listener.enterOpNegExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpNegExpr" ):
                listener.exitOpNegExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpNegExpr" ):
                return visitor.visitOpNegExpr(self)
            else:
                return visitor.visitChildren(self)



    def phi(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = STQLParser.PhiContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_phi, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                localctx = STQLParser.ParenPhiExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 48
                self.match(STQLParser.LPAREN)
                self.state = 49
                self.phi(0)
                self.state = 50
                self.match(STQLParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = STQLParser.BoolAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 52
                self.match(STQLParser.BOOLEAN)
                pass

            elif la_ == 3:
                localctx = STQLParser.OpNegExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 53
                self.match(STQLParser.NEGATION)
                self.state = 54
                self.phi(18)
                pass

            elif la_ == 4:
                localctx = STQLParser.OpNextExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 55
                self.match(STQLParser.NEXTOP)
                self.state = 57
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 56
                    self.interval()


                self.state = 59
                self.phi(17)
                pass

            elif la_ == 5:
                localctx = STQLParser.OpFutureExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 60
                self.match(STQLParser.FUTUREOP)
                self.state = 62
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                if la_ == 1:
                    self.state = 61
                    self.interval()


                self.state = 64
                self.phi(16)
                pass

            elif la_ == 6:
                localctx = STQLParser.OpGloballyExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 65
                self.match(STQLParser.GLOBALLYOP)
                self.state = 67
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                if la_ == 1:
                    self.state = 66
                    self.interval()


                self.state = 69
                self.phi(15)
                pass

            elif la_ == 7:
                localctx = STQLParser.TimeConstraintExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 70
                self.match(STQLParser.CONST_TIME)
                self.state = 71
                self.match(STQLParser.MINUS)
                self.state = 72
                self.match(STQLParser.VAR)
                self.state = 73
                self.match(STQLParser.RELOP)
                self.state = 74
                _la = self._input.LA(1)
                if not(_la==STQLParser.REAL or _la==STQLParser.INT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 8:
                localctx = STQLParser.FrameConstraintExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 75
                self.match(STQLParser.CONST_FRAME)
                self.state = 76
                self.match(STQLParser.MINUS)
                self.state = 77
                self.match(STQLParser.VAR)
                self.state = 78
                self.match(STQLParser.RELOP)
                self.state = 79
                self.match(STQLParser.INT)
                pass

            elif la_ == 9:
                localctx = STQLParser.VariableEquivalenceExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 80
                self.match(STQLParser.VAR)
                self.state = 81
                self.match(STQLParser.EQUALITYOP)
                self.state = 82
                self.match(STQLParser.VAR)
                pass

            elif la_ == 10:
                localctx = STQLParser.OpFreezeTimeExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 83
                self.freezeTime()
                self.state = 84
                self.phi(5)
                pass

            elif la_ == 11:
                localctx = STQLParser.TauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 86
                self.match(STQLParser.SPQUANTIFIEROP)
                self.state = 87
                self.tau(0)
                pass

            elif la_ == 12:
                localctx = STQLParser.PiExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 88
                self.pi()
                pass

            elif la_ == 13:
                localctx = STQLParser.ThetaExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 89
                self.theta()
                pass

            elif la_ == 14:
                localctx = STQLParser.PredicateExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 90
                self.match(STQLParser.PREDICATE)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 125
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 123
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        localctx = STQLParser.OpUntilExprContext(self, STQLParser.PhiContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_phi)
                        self.state = 93
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 94
                        self.match(STQLParser.UNTILOP)
                        self.state = 96
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                        if la_ == 1:
                            self.state = 95
                            self.interval()


                        self.state = 98
                        self.phi(15)
                        pass

                    elif la_ == 2:
                        localctx = STQLParser.OpReleaseExprContext(self, STQLParser.PhiContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_phi)
                        self.state = 99
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 100
                        self.match(STQLParser.RELEASEOP)
                        self.state = 102
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                        if la_ == 1:
                            self.state = 101
                            self.interval()


                        self.state = 104
                        self.phi(14)
                        pass

                    elif la_ == 3:
                        localctx = STQLParser.OpUntilNotStrictExprContext(self, STQLParser.PhiContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_phi)
                        self.state = 105
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 106
                        self.match(STQLParser.UNTILNSOP)
                        self.state = 108
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                        if la_ == 1:
                            self.state = 107
                            self.interval()


                        self.state = 110
                        self.phi(13)
                        pass

                    elif la_ == 4:
                        localctx = STQLParser.OpReleaseNotStrictExprContext(self, STQLParser.PhiContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_phi)
                        self.state = 111
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 112
                        self.match(STQLParser.RELEASENSOP)
                        self.state = 114
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
                        if la_ == 1:
                            self.state = 113
                            self.interval()


                        self.state = 116
                        self.phi(12)
                        pass

                    elif la_ == 5:
                        localctx = STQLParser.OpLogicalExprContext(self, STQLParser.PhiContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_phi)
                        self.state = 117
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 118
                        _la = self._input.LA(1)
                        if not(_la==STQLParser.ANDOP or _la==STQLParser.OROP):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 119
                        self.phi(11)
                        pass

                    elif la_ == 6:
                        localctx = STQLParser.OpPropExprContext(self, STQLParser.PhiContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_phi)
                        self.state = 120
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 121
                        self.match(STQLParser.PROPOP)
                        self.state = 122
                        self.phi(10)
                        pass

             
                self.state = 127
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TauContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return STQLParser.RULE_tau

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class FuncBoundingBoxTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcBB(self):
            return self.getTypedRuleContext(STQLParser.FuncBBContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncBoundingBoxTauExpr" ):
                listener.enterFuncBoundingBoxTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncBoundingBoxTauExpr" ):
                listener.exitFuncBoundingBoxTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncBoundingBoxTauExpr" ):
                return visitor.visitFuncBoundingBoxTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpGloballyTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def GLOBALLYOP(self):
            return self.getToken(STQLParser.GLOBALLYOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpGloballyTauExpr" ):
                listener.enterOpGloballyTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpGloballyTauExpr" ):
                listener.exitOpGloballyTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpGloballyTauExpr" ):
                return visitor.visitOpGloballyTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpReleaseTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def RELEASEOP(self):
            return self.getToken(STQLParser.RELEASEOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpReleaseTauExpr" ):
                listener.enterOpReleaseTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpReleaseTauExpr" ):
                listener.exitOpReleaseTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpReleaseTauExpr" ):
                return visitor.visitOpReleaseTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenTauExpr" ):
                listener.enterParenTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenTauExpr" ):
                listener.exitParenTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenTauExpr" ):
                return visitor.visitParenTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpUntilNotStrictTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def UNTILNSOP(self):
            return self.getToken(STQLParser.UNTILNSOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpUntilNotStrictTauExpr" ):
                listener.enterOpUntilNotStrictTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpUntilNotStrictTauExpr" ):
                listener.exitOpUntilNotStrictTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpUntilNotStrictTauExpr" ):
                return visitor.visitOpUntilNotStrictTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpFutureTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FUTUREOP(self):
            return self.getToken(STQLParser.FUTUREOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpFutureTauExpr" ):
                listener.enterOpFutureTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpFutureTauExpr" ):
                listener.exitOpFutureTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpFutureTauExpr" ):
                return visitor.visitOpFutureTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpReleaseNotStrictTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def RELEASENSOP(self):
            return self.getToken(STQLParser.RELEASENSOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpReleaseNotStrictTauExpr" ):
                listener.enterOpReleaseNotStrictTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpReleaseNotStrictTauExpr" ):
                listener.exitOpReleaseNotStrictTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpReleaseNotStrictTauExpr" ):
                return visitor.visitOpReleaseNotStrictTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpSpaceTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SPACEOP(self):
            return self.getToken(STQLParser.SPACEOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpSpaceTauExpr" ):
                listener.enterOpSpaceTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpSpaceTauExpr" ):
                listener.exitOpSpaceTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpSpaceTauExpr" ):
                return visitor.visitOpSpaceTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class SetTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SET(self):
            return self.getToken(STQLParser.SET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetTauExpr" ):
                listener.enterSetTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetTauExpr" ):
                listener.exitSetTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetTauExpr" ):
                return visitor.visitSetTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpLogicalTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tau(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.TauContext)
            else:
                return self.getTypedRuleContext(STQLParser.TauContext,i)

        def ANDOP(self):
            return self.getToken(STQLParser.ANDOP, 0)
        def OROP(self):
            return self.getToken(STQLParser.OROP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpLogicalTauExpr" ):
                listener.enterOpLogicalTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpLogicalTauExpr" ):
                listener.exitOpLogicalTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpLogicalTauExpr" ):
                return visitor.visitOpLogicalTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpNextTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NEXTOP(self):
            return self.getToken(STQLParser.NEXTOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpNextTauExpr" ):
                listener.enterOpNextTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpNextTauExpr" ):
                listener.exitOpNextTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpNextTauExpr" ):
                return visitor.visitOpNextTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpUntilTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def phi(self):
            return self.getTypedRuleContext(STQLParser.PhiContext,0)

        def UNTILOP(self):
            return self.getToken(STQLParser.UNTILOP, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)

        def interval(self):
            return self.getTypedRuleContext(STQLParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpUntilTauExpr" ):
                listener.enterOpUntilTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpUntilTauExpr" ):
                listener.exitOpUntilTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpUntilTauExpr" ):
                return visitor.visitOpUntilTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class OpNegationTauExprContext(TauContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.TauContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NEGATION(self):
            return self.getToken(STQLParser.NEGATION, 0)
        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpNegationTauExpr" ):
                listener.enterOpNegationTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpNegationTauExpr" ):
                listener.exitOpNegationTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpNegationTauExpr" ):
                return visitor.visitOpNegationTauExpr(self)
            else:
                return visitor.visitChildren(self)



    def tau(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = STQLParser.TauContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_tau, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                localctx = STQLParser.ParenTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 129
                self.match(STQLParser.LPAREN)
                self.state = 130
                self.tau(0)
                self.state = 131
                self.match(STQLParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = STQLParser.SetTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 133
                self.match(STQLParser.SET)
                pass

            elif la_ == 3:
                localctx = STQLParser.FuncBoundingBoxTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 134
                self.funcBB()
                pass

            elif la_ == 4:
                localctx = STQLParser.OpNegationTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 135
                self.match(STQLParser.NEGATION)
                self.state = 136
                self.tau(10)
                pass

            elif la_ == 5:
                localctx = STQLParser.OpSpaceTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 137
                self.match(STQLParser.SPACEOP)
                self.state = 138
                self.tau(8)
                pass

            elif la_ == 6:
                localctx = STQLParser.OpNextTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 139
                self.match(STQLParser.NEXTOP)
                self.state = 141
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                if la_ == 1:
                    self.state = 140
                    self.interval()


                self.state = 143
                self.tau(7)
                pass

            elif la_ == 7:
                localctx = STQLParser.OpFutureTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 144
                self.match(STQLParser.FUTUREOP)
                self.state = 146
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 145
                    self.interval()


                self.state = 148
                self.tau(6)
                pass

            elif la_ == 8:
                localctx = STQLParser.OpGloballyTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 149
                self.match(STQLParser.GLOBALLYOP)
                self.state = 151
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                if la_ == 1:
                    self.state = 150
                    self.interval()


                self.state = 153
                self.tau(5)
                pass

            elif la_ == 9:
                localctx = STQLParser.OpUntilTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 154
                self.phi(0)
                self.state = 155
                self.match(STQLParser.UNTILOP)
                self.state = 157
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                if la_ == 1:
                    self.state = 156
                    self.interval()


                self.state = 159
                self.tau(4)
                pass

            elif la_ == 10:
                localctx = STQLParser.OpReleaseTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 161
                self.phi(0)
                self.state = 162
                self.match(STQLParser.RELEASEOP)
                self.state = 164
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                if la_ == 1:
                    self.state = 163
                    self.interval()


                self.state = 166
                self.tau(3)
                pass

            elif la_ == 11:
                localctx = STQLParser.OpUntilNotStrictTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 168
                self.phi(0)
                self.state = 169
                self.match(STQLParser.UNTILNSOP)
                self.state = 171
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                if la_ == 1:
                    self.state = 170
                    self.interval()


                self.state = 173
                self.tau(2)
                pass

            elif la_ == 12:
                localctx = STQLParser.OpReleaseNotStrictTauExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 175
                self.phi(0)
                self.state = 176
                self.match(STQLParser.RELEASENSOP)
                self.state = 178
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
                if la_ == 1:
                    self.state = 177
                    self.interval()


                self.state = 180
                self.tau(1)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 189
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = STQLParser.OpLogicalTauExprContext(self, STQLParser.TauContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_tau)
                    self.state = 184
                    if not self.precpred(self._ctx, 9):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                    self.state = 185
                    _la = self._input.LA(1)
                    if not(_la==STQLParser.ANDOP or _la==STQLParser.OROP):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 186
                    self.tau(10) 
                self.state = 191
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PiContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return STQLParser.RULE_pi

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ParenPiExprContext(PiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)
        def pi(self):
            return self.getTypedRuleContext(STQLParser.PiContext,0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenPiExpr" ):
                listener.enterParenPiExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenPiExpr" ):
                listener.exitParenPiExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenPiExpr" ):
                return visitor.visitParenPiExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncAreaTauExprContext(PiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcAreaTau(self):
            return self.getTypedRuleContext(STQLParser.FuncAreaTauContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncAreaTauExpr" ):
                listener.enterFuncAreaTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncAreaTauExpr" ):
                listener.exitFuncAreaTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncAreaTauExpr" ):
                return visitor.visitFuncAreaTauExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncRatioAreaTauExprContext(PiContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.PiContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcRatioAreaTau(self):
            return self.getTypedRuleContext(STQLParser.FuncRatioAreaTauContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioAreaTauExpr" ):
                listener.enterFuncRatioAreaTauExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioAreaTauExpr" ):
                listener.exitFuncRatioAreaTauExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioAreaTauExpr" ):
                return visitor.visitFuncRatioAreaTauExpr(self)
            else:
                return visitor.visitChildren(self)



    def pi(self):

        localctx = STQLParser.PiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_pi)
        try:
            self.state = 204
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [STQLParser.LPAREN]:
                localctx = STQLParser.ParenPiExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 192
                self.match(STQLParser.LPAREN)
                self.state = 193
                self.pi()
                self.state = 194
                self.match(STQLParser.RPAREN)
                pass
            elif token in [STQLParser.T__1]:
                localctx = STQLParser.FuncAreaTauExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.funcAreaTau()
                self.state = 197
                self.match(STQLParser.RELOP)
                self.state = 198
                self.match(STQLParser.REAL)
                pass
            elif token in [STQLParser.T__2]:
                localctx = STQLParser.FuncRatioAreaTauExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 200
                self.funcRatioAreaTau()
                self.state = 201
                self.match(STQLParser.RELOP)
                self.state = 202
                self.match(STQLParser.REAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return STQLParser.RULE_theta

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FuncAreaThetaExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcAreaTheta(self):
            return self.getTypedRuleContext(STQLParser.FuncAreaThetaContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncAreaThetaExpr" ):
                listener.enterFuncAreaThetaExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncAreaThetaExpr" ):
                listener.exitFuncAreaThetaExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncAreaThetaExpr" ):
                return visitor.visitFuncAreaThetaExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncClassExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcClass(self):
            return self.getTypedRuleContext(STQLParser.FuncClassContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def INT(self):
            return self.getToken(STQLParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncClassExpr" ):
                listener.enterFuncClassExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncClassExpr" ):
                listener.exitFuncClassExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncClassExpr" ):
                return visitor.visitFuncClassExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncEuclideanDistancExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcDist(self):
            return self.getTypedRuleContext(STQLParser.FuncDistContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncEuclideanDistancExpr" ):
                listener.enterFuncEuclideanDistancExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncEuclideanDistancExpr" ):
                listener.exitFuncEuclideanDistancExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncEuclideanDistancExpr" ):
                return visitor.visitFuncEuclideanDistancExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncCompareClassExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcClass(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.FuncClassContext)
            else:
                return self.getTypedRuleContext(STQLParser.FuncClassContext,i)

        def EQUALITYOP(self):
            return self.getToken(STQLParser.EQUALITYOP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncCompareClassExpr" ):
                listener.enterFuncCompareClassExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncCompareClassExpr" ):
                listener.exitFuncCompareClassExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncCompareClassExpr" ):
                return visitor.visitFuncCompareClassExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenThetaExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)
        def theta(self):
            return self.getTypedRuleContext(STQLParser.ThetaContext,0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenThetaExpr" ):
                listener.enterParenThetaExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenThetaExpr" ):
                listener.exitParenThetaExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenThetaExpr" ):
                return visitor.visitParenThetaExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncProbExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcProb(self):
            return self.getTypedRuleContext(STQLParser.FuncProbContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncProbExpr" ):
                listener.enterFuncProbExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncProbExpr" ):
                listener.exitFuncProbExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncProbExpr" ):
                return visitor.visitFuncProbExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncLatituteExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcLatDist(self):
            return self.getTypedRuleContext(STQLParser.FuncLatDistContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncLatituteExpr" ):
                listener.enterFuncLatituteExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncLatituteExpr" ):
                listener.exitFuncLatituteExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncLatituteExpr" ):
                return visitor.visitFuncLatituteExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncRatioLatLonExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcRatioLatLon(self):
            return self.getTypedRuleContext(STQLParser.FuncRatioLatLonContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioLatLonExpr" ):
                listener.enterFuncRatioLatLonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioLatLonExpr" ):
                listener.exitFuncRatioLatLonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioLatLonExpr" ):
                return visitor.visitFuncRatioLatLonExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncLongitudeExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcLonDist(self):
            return self.getTypedRuleContext(STQLParser.FuncLonDistContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncLongitudeExpr" ):
                listener.enterFuncLongitudeExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncLongitudeExpr" ):
                listener.exitFuncLongitudeExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncLongitudeExpr" ):
                return visitor.visitFuncLongitudeExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncRatioAreaThetaExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcRatioArea(self):
            return self.getTypedRuleContext(STQLParser.FuncRatioAreaContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioAreaThetaExpr" ):
                listener.enterFuncRatioAreaThetaExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioAreaThetaExpr" ):
                listener.exitFuncRatioAreaThetaExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioAreaThetaExpr" ):
                return visitor.visitFuncRatioAreaThetaExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncRatioProbExprContext(ThetaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a STQLParser.ThetaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def funcRatioProb(self):
            return self.getTypedRuleContext(STQLParser.FuncRatioProbContext,0)

        def RELOP(self):
            return self.getToken(STQLParser.RELOP, 0)
        def REAL(self):
            return self.getToken(STQLParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioProbExpr" ):
                listener.enterFuncRatioProbExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioProbExpr" ):
                listener.exitFuncRatioProbExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioProbExpr" ):
                return visitor.visitFuncRatioProbExpr(self)
            else:
                return visitor.visitChildren(self)



    def theta(self):

        localctx = STQLParser.ThetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_theta)
        try:
            self.state = 250
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                localctx = STQLParser.ParenThetaExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 206
                self.match(STQLParser.LPAREN)
                self.state = 207
                self.theta()
                self.state = 208
                self.match(STQLParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = STQLParser.FuncEuclideanDistancExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 210
                self.funcDist()
                self.state = 211
                self.match(STQLParser.RELOP)
                self.state = 212
                self.match(STQLParser.REAL)
                pass

            elif la_ == 3:
                localctx = STQLParser.FuncLatituteExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 214
                self.funcLatDist()
                self.state = 215
                self.match(STQLParser.RELOP)
                self.state = 216
                self.match(STQLParser.REAL)
                pass

            elif la_ == 4:
                localctx = STQLParser.FuncLongitudeExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 218
                self.funcLonDist()
                self.state = 219
                self.match(STQLParser.RELOP)
                self.state = 220
                self.match(STQLParser.REAL)
                pass

            elif la_ == 5:
                localctx = STQLParser.FuncRatioLatLonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 222
                self.funcRatioLatLon()
                self.state = 223
                self.match(STQLParser.RELOP)
                self.state = 224
                self.match(STQLParser.REAL)
                pass

            elif la_ == 6:
                localctx = STQLParser.FuncAreaThetaExprContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 226
                self.funcAreaTheta()
                self.state = 227
                self.match(STQLParser.RELOP)
                self.state = 228
                self.match(STQLParser.REAL)
                pass

            elif la_ == 7:
                localctx = STQLParser.FuncRatioAreaThetaExprContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 230
                self.funcRatioArea()
                self.state = 231
                self.match(STQLParser.RELOP)
                self.state = 232
                self.match(STQLParser.REAL)
                pass

            elif la_ == 8:
                localctx = STQLParser.FuncClassExprContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 234
                self.funcClass()
                self.state = 235
                self.match(STQLParser.RELOP)
                self.state = 236
                self.match(STQLParser.INT)
                pass

            elif la_ == 9:
                localctx = STQLParser.FuncCompareClassExprContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 238
                self.funcClass()
                self.state = 239
                self.match(STQLParser.EQUALITYOP)
                self.state = 240
                self.funcClass()
                pass

            elif la_ == 10:
                localctx = STQLParser.FuncProbExprContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 242
                self.funcProb()
                self.state = 243
                self.match(STQLParser.RELOP)
                self.state = 244
                self.match(STQLParser.REAL)
                pass

            elif la_ == 11:
                localctx = STQLParser.FuncRatioProbExprContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 246
                self.funcRatioProb()
                self.state = 247
                self.match(STQLParser.RELOP)
                self.state = 248
                self.match(STQLParser.REAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FreezeTimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(STQLParser.AT, 0)

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def timeVarDecl(self):
            return self.getTypedRuleContext(STQLParser.TimeVarDeclContext,0)


        def objVarDecl(self):
            return self.getTypedRuleContext(STQLParser.ObjVarDeclContext,0)


        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_freezeTime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreezeTime" ):
                listener.enterFreezeTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreezeTime" ):
                listener.exitFreezeTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreezeTime" ):
                return visitor.visitFreezeTime(self)
            else:
                return visitor.visitChildren(self)




    def freezeTime(self):

        localctx = STQLParser.FreezeTimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_freezeTime)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.match(STQLParser.AT)
            self.state = 253
            self.match(STQLParser.LPAREN)
            self.state = 260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 254
                self.timeVarDecl()
                pass

            elif la_ == 2:
                self.state = 255
                self.objVarDecl()
                pass

            elif la_ == 3:
                self.state = 256
                self.timeVarDecl()
                self.state = 257
                self.match(STQLParser.COMMA)
                self.state = 258
                self.objVarDecl()
                pass


            self.state = 262
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeVarDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def UNDERSCORE(self):
            return self.getToken(STQLParser.UNDERSCORE, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_timeVarDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeVarDecl" ):
                listener.enterTimeVarDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeVarDecl" ):
                listener.exitTimeVarDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeVarDecl" ):
                return visitor.visitTimeVarDecl(self)
            else:
                return visitor.visitChildren(self)




    def timeVarDecl(self):

        localctx = STQLParser.TimeVarDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_timeVarDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            _la = self._input.LA(1)
            if not(_la==STQLParser.UNDERSCORE or _la==STQLParser.VAR):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjVarDeclContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUANTIFIEROP(self):
            return self.getToken(STQLParser.QUANTIFIEROP, 0)

        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def varList(self):
            return self.getTypedRuleContext(STQLParser.VarListContext,0)


        def getRuleIndex(self):
            return STQLParser.RULE_objVarDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjVarDecl" ):
                listener.enterObjVarDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjVarDecl" ):
                listener.exitObjVarDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjVarDecl" ):
                return visitor.visitObjVarDecl(self)
            else:
                return visitor.visitChildren(self)




    def objVarDecl(self):

        localctx = STQLParser.ObjVarDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_objVarDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(STQLParser.QUANTIFIEROP)
            self.state = 267
            self.match(STQLParser.COMMA)
            self.state = 268
            self.varList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def varList(self):
            return self.getTypedRuleContext(STQLParser.VarListContext,0)


        def getRuleIndex(self):
            return STQLParser.RULE_varList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarList" ):
                listener.enterVarList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarList" ):
                listener.exitVarList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarList" ):
                return visitor.visitVarList(self)
            else:
                return visitor.visitChildren(self)




    def varList(self):

        localctx = STQLParser.VarListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_varList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 270
                self.match(STQLParser.VAR)
                pass

            elif la_ == 2:
                self.state = 271
                self.match(STQLParser.VAR)
                self.state = 272
                self.match(STQLParser.COMMA)
                self.state = 273
                self.varList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def LBRACK(self):
            return self.getToken(STQLParser.LBRACK, 0)

        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.INT)
            else:
                return self.getToken(STQLParser.INT, i)

        def REAL(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.REAL)
            else:
                return self.getToken(STQLParser.REAL, i)

        def INF(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.INF)
            else:
                return self.getToken(STQLParser.INF, i)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def RBRACK(self):
            return self.getToken(STQLParser.RBRACK, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_interval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval" ):
                listener.enterInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval" ):
                listener.exitInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterval" ):
                return visitor.visitInterval(self)
            else:
                return visitor.visitChildren(self)




    def interval(self):

        localctx = STQLParser.IntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_interval)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            _la = self._input.LA(1)
            if not(_la==STQLParser.LPAREN or _la==STQLParser.LBRACK):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 277
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << STQLParser.INF) | (1 << STQLParser.REAL) | (1 << STQLParser.INT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 278
            self.match(STQLParser.COMMA)
            self.state = 279
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << STQLParser.INF) | (1 << STQLParser.REAL) | (1 << STQLParser.INT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 280
            _la = self._input.LA(1)
            if not(_la==STQLParser.RPAREN or _la==STQLParser.RBRACK):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncBBContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcBB

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncBB" ):
                listener.enterFuncBB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncBB" ):
                listener.exitFuncBB(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncBB" ):
                return visitor.visitFuncBB(self)
            else:
                return visitor.visitChildren(self)




    def funcBB(self):

        localctx = STQLParser.FuncBBContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_funcBB)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(STQLParser.T__0)
            self.state = 283
            self.match(STQLParser.LPAREN)
            self.state = 284
            self.match(STQLParser.VAR)
            self.state = 285
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncAreaTauContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def tau(self):
            return self.getTypedRuleContext(STQLParser.TauContext,0)


        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcAreaTau

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncAreaTau" ):
                listener.enterFuncAreaTau(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncAreaTau" ):
                listener.exitFuncAreaTau(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncAreaTau" ):
                return visitor.visitFuncAreaTau(self)
            else:
                return visitor.visitChildren(self)




    def funcAreaTau(self):

        localctx = STQLParser.FuncAreaTauContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_funcAreaTau)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(STQLParser.T__1)
            self.state = 288
            self.match(STQLParser.LPAREN)
            self.state = 289
            self.tau(0)
            self.state = 290
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncRatioAreaTauContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def funcAreaTau(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.FuncAreaTauContext)
            else:
                return self.getTypedRuleContext(STQLParser.FuncAreaTauContext,i)


        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcRatioAreaTau

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioAreaTau" ):
                listener.enterFuncRatioAreaTau(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioAreaTau" ):
                listener.exitFuncRatioAreaTau(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioAreaTau" ):
                return visitor.visitFuncRatioAreaTau(self)
            else:
                return visitor.visitChildren(self)




    def funcRatioAreaTau(self):

        localctx = STQLParser.FuncRatioAreaTauContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_funcRatioAreaTau)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.match(STQLParser.T__2)
            self.state = 293
            self.match(STQLParser.LPAREN)
            self.state = 294
            self.funcAreaTau()
            self.state = 295
            self.match(STQLParser.COMMA)
            self.state = 296
            self.funcAreaTau()
            self.state = 297
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncDistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.VAR)
            else:
                return self.getToken(STQLParser.VAR, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.COMMA)
            else:
                return self.getToken(STQLParser.COMMA, i)

        def CRT(self, i:int=None):
            if i is None:
                return self.getTokens(STQLParser.CRT)
            else:
                return self.getToken(STQLParser.CRT, i)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcDist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncDist" ):
                listener.enterFuncDist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncDist" ):
                listener.exitFuncDist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncDist" ):
                return visitor.visitFuncDist(self)
            else:
                return visitor.visitChildren(self)




    def funcDist(self):

        localctx = STQLParser.FuncDistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_funcDist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(STQLParser.T__3)
            self.state = 300
            self.match(STQLParser.LPAREN)
            self.state = 301
            self.match(STQLParser.VAR)
            self.state = 302
            self.match(STQLParser.COMMA)
            self.state = 303
            self.match(STQLParser.CRT)
            self.state = 304
            self.match(STQLParser.COMMA)
            self.state = 305
            self.match(STQLParser.VAR)
            self.state = 306
            self.match(STQLParser.COMMA)
            self.state = 307
            self.match(STQLParser.CRT)
            self.state = 308
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncLatDistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def CRT(self):
            return self.getToken(STQLParser.CRT, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcLatDist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncLatDist" ):
                listener.enterFuncLatDist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncLatDist" ):
                listener.exitFuncLatDist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncLatDist" ):
                return visitor.visitFuncLatDist(self)
            else:
                return visitor.visitChildren(self)




    def funcLatDist(self):

        localctx = STQLParser.FuncLatDistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_funcLatDist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(STQLParser.T__4)
            self.state = 311
            self.match(STQLParser.LPAREN)
            self.state = 312
            self.match(STQLParser.VAR)
            self.state = 313
            self.match(STQLParser.COMMA)
            self.state = 314
            self.match(STQLParser.CRT)
            self.state = 315
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncLonDistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def CRT(self):
            return self.getToken(STQLParser.CRT, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcLonDist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncLonDist" ):
                listener.enterFuncLonDist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncLonDist" ):
                listener.exitFuncLonDist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncLonDist" ):
                return visitor.visitFuncLonDist(self)
            else:
                return visitor.visitChildren(self)




    def funcLonDist(self):

        localctx = STQLParser.FuncLonDistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_funcLonDist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            self.match(STQLParser.T__5)
            self.state = 318
            self.match(STQLParser.LPAREN)
            self.state = 319
            self.match(STQLParser.VAR)
            self.state = 320
            self.match(STQLParser.COMMA)
            self.state = 321
            self.match(STQLParser.CRT)
            self.state = 322
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncRatioLatLonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def funcLatDist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.FuncLatDistContext)
            else:
                return self.getTypedRuleContext(STQLParser.FuncLatDistContext,i)


        def funcLonDist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.FuncLonDistContext)
            else:
                return self.getTypedRuleContext(STQLParser.FuncLonDistContext,i)


        def getRuleIndex(self):
            return STQLParser.RULE_funcRatioLatLon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioLatLon" ):
                listener.enterFuncRatioLatLon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioLatLon" ):
                listener.exitFuncRatioLatLon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioLatLon" ):
                return visitor.visitFuncRatioLatLon(self)
            else:
                return visitor.visitChildren(self)




    def funcRatioLatLon(self):

        localctx = STQLParser.FuncRatioLatLonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_funcRatioLatLon)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(STQLParser.T__2)
            self.state = 325
            self.match(STQLParser.LPAREN)
            self.state = 328
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [STQLParser.T__4]:
                self.state = 326
                self.funcLatDist()
                pass
            elif token in [STQLParser.T__5]:
                self.state = 327
                self.funcLonDist()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 330
            self.match(STQLParser.COMMA)
            self.state = 333
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [STQLParser.T__4]:
                self.state = 331
                self.funcLatDist()
                pass
            elif token in [STQLParser.T__5]:
                self.state = 332
                self.funcLonDist()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 335
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncAreaThetaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcAreaTheta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncAreaTheta" ):
                listener.enterFuncAreaTheta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncAreaTheta" ):
                listener.exitFuncAreaTheta(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncAreaTheta" ):
                return visitor.visitFuncAreaTheta(self)
            else:
                return visitor.visitChildren(self)




    def funcAreaTheta(self):

        localctx = STQLParser.FuncAreaThetaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_funcAreaTheta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 337
            self.match(STQLParser.T__1)
            self.state = 338
            self.match(STQLParser.LPAREN)
            self.state = 339
            self.match(STQLParser.VAR)
            self.state = 340
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncRatioAreaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def funcAreaTau(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.FuncAreaTauContext)
            else:
                return self.getTypedRuleContext(STQLParser.FuncAreaTauContext,i)


        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcRatioArea

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioArea" ):
                listener.enterFuncRatioArea(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioArea" ):
                listener.exitFuncRatioArea(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioArea" ):
                return visitor.visitFuncRatioArea(self)
            else:
                return visitor.visitChildren(self)




    def funcRatioArea(self):

        localctx = STQLParser.FuncRatioAreaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_funcRatioArea)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(STQLParser.T__2)
            self.state = 343
            self.match(STQLParser.LPAREN)
            self.state = 344
            self.funcAreaTau()
            self.state = 345
            self.match(STQLParser.COMMA)
            self.state = 346
            self.funcAreaTau()
            self.state = 347
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncClassContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcClass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncClass" ):
                listener.enterFuncClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncClass" ):
                listener.exitFuncClass(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncClass" ):
                return visitor.visitFuncClass(self)
            else:
                return visitor.visitChildren(self)




    def funcClass(self):

        localctx = STQLParser.FuncClassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_funcClass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(STQLParser.T__6)
            self.state = 350
            self.match(STQLParser.LPAREN)
            self.state = 351
            self.match(STQLParser.VAR)
            self.state = 352
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncProbContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(STQLParser.VAR, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcProb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncProb" ):
                listener.enterFuncProb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncProb" ):
                listener.exitFuncProb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncProb" ):
                return visitor.visitFuncProb(self)
            else:
                return visitor.visitChildren(self)




    def funcProb(self):

        localctx = STQLParser.FuncProbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_funcProb)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 354
            self.match(STQLParser.T__7)
            self.state = 355
            self.match(STQLParser.LPAREN)
            self.state = 356
            self.match(STQLParser.VAR)
            self.state = 357
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncRatioProbContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(STQLParser.LPAREN, 0)

        def funcProb(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(STQLParser.FuncProbContext)
            else:
                return self.getTypedRuleContext(STQLParser.FuncProbContext,i)


        def COMMA(self):
            return self.getToken(STQLParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(STQLParser.RPAREN, 0)

        def getRuleIndex(self):
            return STQLParser.RULE_funcRatioProb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncRatioProb" ):
                listener.enterFuncRatioProb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncRatioProb" ):
                listener.exitFuncRatioProb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncRatioProb" ):
                return visitor.visitFuncRatioProb(self)
            else:
                return visitor.visitChildren(self)




    def funcRatioProb(self):

        localctx = STQLParser.FuncRatioProbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_funcRatioProb)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(STQLParser.T__2)
            self.state = 360
            self.match(STQLParser.LPAREN)
            self.state = 361
            self.funcProb()
            self.state = 362
            self.match(STQLParser.COMMA)
            self.state = 363
            self.funcProb()
            self.state = 364
            self.match(STQLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[1] = self.phi_sempred
        self._predicates[2] = self.tau_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def phi_sempred(self, localctx:PhiContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 9)
         

    def tau_sempred(self, localctx:TauContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 9)
         




